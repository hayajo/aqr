#!/usr/bin/env perl

use strict;
use warnings;

require 'syscall.ph';

use Errno ();
use File::Basename qw/dirname/;
use File::Spec::Functions qw/catfile catdir rel2abs file_name_is_absolute/;
use Getopt::Long;
use POSIX;
use Pod::Usage qw/pod2usage/;

our $VERSION = '0.01';

use constant {
    DEFAULT_CMD => [qw|/bin/sh -l|],
    MOUNTS      => '/proc/mounts',
    BINDS       => [
        { src => 'none',     dest => '/proc',     type => 'proc', opts => [] },
        { src => '/sys',     dest => '/sys',      type => 'none', opts => [qw/rbind/] },
        { src => '/dev/pts', dest => '/dev/pts',  type => 'none', opts => [qw/bind/] },
    ],
    DEVS => [
        { name => 'null',    type => 'c', major => 1, minor => 3, opts => [qw/--mode=666/] },
        { name => 'zero',    type => 'c', major => 1, minor => 5, opts => [qw/--mode=666/] },
        { name => 'full',    type => 'c', major => 1, minor => 7, opts => [qw/--mode=666/] },
        { name => 'random',  type => 'c', major => 1, minor => 8, opts => [qw/--mode=644/] },
        { name => 'urandom', type => 'c', major => 1, minor => 9, opts => [qw/--mode=644/] },
        { name => 'tty',     type => 'c', major => 5, minor => 0, opts => [qw/--mode=666/] },
        { name => 'ptmx',    type => 'c', major => 5, minor => 2, opts => [qw/--mode=666/] },
    ],
    COPY_FILES => [
        # '/etc/passwd',
        # '/etc/shadow',
        # '/etc/group',
        # '/etc/gshadow',
        # '/etc/services',
        # '/etc/protocols',
        '/etc/networks',
        '/etc/hosts',
        '/etc/hostname',
        '/etc/localtime',
        '/etc/resolv.conf',
    ],
    KEEP_CAPS => [
        0,  # CAP_CHOWN
        1,  # CAP_DAC_OVERRIDE
        2,  # CAP_DAC_READ_SEARCH
        3,  # CAP_FOWNER
        4,  # CAP_FSETID
        5,  # CAP_KILL
        6,  # CAP_SETGID
        7,  # CAP_SETUID
        8,  # CAP_SETPCAP
        10, # CAP_NET_BIND_SERVICE
        13, # CAP_NET_RAW
        18, # CAP_SYS_CHROOT
        27, # CAP_MKNOD
        29, # CAP_AUDIT_WRITE
        31, # CAP_SETFCAP
    ],
};

sub main {
    die basename($0) . ' should be run as root'
        if $< != 0;

    my %opts = (
        cwd          => '/',
        bind         => [],
        robind       => [],
        copy         => [],
        env          => [],
        user         => 'root',
        # group        => 'root',
        no_drop_caps => 0,
    );

    GetOptions(
        \%opts,
        'cwd=s',
        'bind=s',
        'robind=s',
        'copy=s',
        'env=s',
        'user=s',
        # 'group=s',
        'no-drop-caps',
    ) or exit(1);

    pod2usage(1) if (!@ARGV);

    my $rootfs = shift @ARGV;
    my $root = resolve_name($rootfs)
        or die "$rootfs does not exists";

    die "failed to unshare mount"
        if  syscall(&SYS_unshare, 131072) < 0; # CLONE_NEWNS
    # syscall(&SYS_mount, '', '/', 0, 262144, 0); # MS_PRIVATE
    run_cmd(qw|mount --make-private /|);

    mount($_->{src}, catdir($root, $_->{dest}), $_->{type}, @{$_->{opts}})
        for (@{&BINDS});
    mount($_->[0], catdir($root, $_->[1]), 'none', qw/bind/)
        for (map{ extract_names($_) } @{$opts{bind}});
    mount($_->[0], catdir($root, $_->[1]), 'none', qw/bind ro remount/)
        for (map{ extract_names($_) } @{$opts{robind}});

    make_device(catfile($root, 'dev', $_->{name}), $_->{type}, $_->{major}, $_->{minor}, @{$_->{opts}})
        for (@{&DEVS});

    copy($_, catfile($root, $_))
        for (@{&COPY_FILES});
    copy($_->[0], catfile($root, $_->[1]))
        for (map { extract_names($_) } @{$opts{copy}});

    chroot $root
        or die "failed to chroot to $root: $!";
    chdir $opts{cwd}
        or die "failed to chdir to $opts{cwd}: $!";

    drop_caps()
        if ! $opts{no_drop_caps};

    set_uidgid($opts{user});

    set_env(@{$opts{env}});

    my @cmd = (@ARGV) ? @ARGV : @{&DEFAULT_CMD};
    exec @cmd;

    die "failed to exec $cmd[0]: $!";
}

sub resolve_name {
    my $name = shift || return;
    my $abs = rel2abs( (-l $name) ? readlink $name : $name );
    return (-e $abs) ? $abs : undef;
}

sub extract_names {
    my $name = shift || return;
    my ($src, $dest) = split /:/, $name;
    $dest ||= $src;

    for ($src, $dest) {
        file_name_is_absolute($_)
            or die "$_ must be absolute";
    }
    return [$src, $dest];
}

sub run_cmd {
    my @argv = @_;
    system(@argv) == 0
        or die "failed to exec $argv[0]: $!";
}

sub mount {
    my ($src, $dest, $type, @opts) = @_;

    run_cmd(qw/mkdir -p -m 0755/, $dest)
        if ! -e $dest;

    opendir my $dh, $dest
        or die "failed to open $dest: $!";
    while (my $name = readdir $dh) {
        return $dest if $name ne '.' && $name ne '..';
    }
    close $dh;

    # CMD: mount [-t <$type>] [-o <$opts[0],$opts[1],...>] <$src> <$dest>
    my @cmd = qw/mount/;
    push @cmd, '-t', $type
        if $type;
    push @cmd, '-o', join ',', @opts
        if @opts;
    push @cmd, $src, $dest;

    run_cmd(@cmd);

    return $dest;
}

sub make_device {
    my ($name, $type, $major, $minor, @opts) = @_;

    my $dir = dirname($name);
    run_cmd(qw/mkdir -p -m 0755/, $dir) unless -e $dir;

    unlink $name if -e $name;

    # CMD: mknod [OPTION]... NAME TYPE MAJOR MINOR
    run_cmd('mknod', @opts, $name, $type, $major, $minor);
}

sub copy {
    my ($src, $dest) = @_;
    run_cmd('cp', '-pH', $src, $dest); # follow symlink
}

sub drop_caps {
    my %keep_caps = map { $_ => 1 } @{&KEEP_CAPS};

    my $i;
    for ($i = 0; ; ++$i) {
        next if $keep_caps{$i};

        last if syscall(&SYS_prctl, 23, $i) < 0; # PR_CAPBSET_READ

        if (syscall(&SYS_prctl, 24, $i) < 0) { # PR_CAPBSET_DROP
            warn "failed to drop capability:$i";
        }
    }

    # we should at least succeed in dropping _some_ capabilities
    die "failed to drop capabilities:$!"
        if $i == 0;
}

sub set_uidgid {
    my $user = shift || return;

    open my $fh, '<', '/etc/passwd'
        or die "failed to open /etc/passwd: $!";

    my ($uid, $gid);

    while (<$fh>) {
        chomp;
        # see: man 5 passwd
        #  name:password:UID:GID:GECOS:directory:shell
        my ($_name, $_uid, $_gid) = (split /:/, $_)[0, 2, 3];
        if ($user eq $_uid || $user eq $_name) {
            ($uid, $gid) = ($_uid, $_gid);
        }
    }

    die "invalid user '$user'" if ! defined $uid;

    # NOTICE: must set GID before set UID.
    POSIX::setgid($gid);
    POSIX::setuid($uid);
}

sub set_env {
    for (@_) {
        my ($var, $val) = split /=/, $_;
        $ENV{$var} = $val;
    }
}

main;

__END__

=head1 NAME

aqr - alternative `docker run`

=head1 SYNOPSIS

    # create a root filesystem with docker.
    docker export (docker create alpine hostname) | gzip > rootfs.tar.gz

    # execute a command inside the rootfs.
    sudo tar xzf rootfs.tar.gz -C /path/ro/rootfs
    sudo aqr /path/to/rootfs -- /bin/sh -l

=head1 DESCRIPTION

`aqr` is a easy container to run with chroot instead of `docker run`.

=head1 OPTIONS

=head2 --cwd

default: /

working directory.

=head2 --bind src_path[:dest_path]

default: []

mount src_path of host to dest_path of the rootfs.

=head2 --robind src_path[:dest_path]

default: []

mount read-only src_path of host to dest_path of the rootfs.

=head2 --copy src_path[:dest_path]

default: []

copy src_path of host to dest_path of the rootfs.

=head2 --env var=val

default: []

set environment variables.

=head2 --user name|id

default: 'root'

usename or UID

=head2 --group name|id

default: 'root'

DEPRECATED

=head2 --no-drop-caps

default: false

give extended privileges to this container.

=head1 AUTHOR

hayajo E<lt>hayajo@cpan.orgE<gt>

=head1 SEE ALSO

L<https://github.com/yuuki/droot>
L<https://github.com/kazuho/jailing>
L<https://github.com/opencontainers/runc>
L<https://github.com/opencontainers/runc/blob/master/libcontainer/SPEC.md>

=head1 LICENSE

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut

# -*- mode: perl -*-
# vi: set ft=perl :
